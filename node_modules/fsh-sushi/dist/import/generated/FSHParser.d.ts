declare class FSHParser extends antlr4.Parser {
    static grammarFileName: string;
    static literalNames: string[];
    static symbolicNames: string[];
    static ruleNames: string[];
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: string[];
    symbolicNames: string[];
    get atn(): any;
    doc(): DocContext;
    entity(): EntityContext;
    alias(): AliasContext;
    profile(): ProfileContext;
    extension(): ExtensionContext;
    logical(): LogicalContext;
    resource(): ResourceContext;
    sdMetadata(): SdMetadataContext;
    sdRule(): SdRuleContext;
    lrRule(): LrRuleContext;
    instance(): InstanceContext;
    instanceMetadata(): InstanceMetadataContext;
    instanceRule(): InstanceRuleContext;
    invariant(): InvariantContext;
    invariantMetadata(): InvariantMetadataContext;
    invariantRule(): InvariantRuleContext;
    valueSet(): ValueSetContext;
    vsMetadata(): VsMetadataContext;
    vsRule(): VsRuleContext;
    codeSystem(): CodeSystemContext;
    csMetadata(): CsMetadataContext;
    csRule(): CsRuleContext;
    ruleSet(): RuleSetContext;
    ruleSetRule(): RuleSetRuleContext;
    paramRuleSet(): ParamRuleSetContext;
    paramRuleSetRef(): ParamRuleSetRefContext;
    parameter(): ParameterContext;
    lastParameter(): LastParameterContext;
    paramRuleSetContent(): ParamRuleSetContentContext;
    mapping(): MappingContext;
    mappingMetadata(): MappingMetadataContext;
    mappingEntityRule(): MappingEntityRuleContext;
    parent(): ParentContext;
    id(): IdContext;
    title(): TitleContext;
    description(): DescriptionContext;
    expression(): ExpressionContext;
    xpath(): XpathContext;
    severity(): SeverityContext;
    instanceOf(): InstanceOfContext;
    usage(): UsageContext;
    source(): SourceContext;
    target(): TargetContext;
    cardRule(): CardRuleContext;
    flagRule(): FlagRuleContext;
    valueSetRule(): ValueSetRuleContext;
    fixedValueRule(): FixedValueRuleContext;
    containsRule(): ContainsRuleContext;
    onlyRule(): OnlyRuleContext;
    obeysRule(): ObeysRuleContext;
    caretValueRule(): CaretValueRuleContext;
    codeCaretValueRule(): CodeCaretValueRuleContext;
    mappingRule(): MappingRuleContext;
    insertRule(): InsertRuleContext;
    codeInsertRule(): CodeInsertRuleContext;
    addCRElementRule(): AddCRElementRuleContext;
    addElementRule(): AddElementRuleContext;
    pathRule(): PathRuleContext;
    vsComponent(): VsComponentContext;
    vsConceptComponent(): VsConceptComponentContext;
    vsFilterComponent(): VsFilterComponentContext;
    vsComponentFrom(): VsComponentFromContext;
    vsFromSystem(): VsFromSystemContext;
    vsFromValueset(): VsFromValuesetContext;
    vsFilterList(): VsFilterListContext;
    vsFilterDefinition(): VsFilterDefinitionContext;
    vsFilterOperator(): VsFilterOperatorContext;
    vsFilterValue(): VsFilterValueContext;
    name(): NameContext;
    path(): PathContext;
    caretPath(): CaretPathContext;
    flag(): FlagContext;
    strength(): StrengthContext;
    value(): ValueContext;
    item(): ItemContext;
    code(): CodeContext;
    concept(): ConceptContext;
    quantity(): QuantityContext;
    ratio(): RatioContext;
    reference(): ReferenceContext;
    referenceType(): ReferenceTypeContext;
    canonical(): CanonicalContext;
    ratioPart(): RatioPartContext;
    bool(): BoolContext;
    targetType(): TargetTypeContext;
    mostAlphaKeywords(): MostAlphaKeywordsContext;
}
declare namespace FSHParser {
    export const EOF: number;
    export const KW_ALIAS: number;
    export const KW_PROFILE: number;
    export const KW_EXTENSION: number;
    export const KW_INSTANCE: number;
    export const KW_INSTANCEOF: number;
    export const KW_INVARIANT: number;
    export const KW_VALUESET: number;
    export const KW_CODESYSTEM: number;
    export const KW_RULESET: number;
    export const KW_MAPPING: number;
    export const KW_LOGICAL: number;
    export const KW_RESOURCE: number;
    export const KW_PARENT: number;
    export const KW_ID: number;
    export const KW_TITLE: number;
    export const KW_DESCRIPTION: number;
    export const KW_EXPRESSION: number;
    export const KW_XPATH: number;
    export const KW_SEVERITY: number;
    export const KW_USAGE: number;
    export const KW_SOURCE: number;
    export const KW_TARGET: number;
    export const KW_MOD: number;
    export const KW_MS: number;
    export const KW_SU: number;
    export const KW_TU: number;
    export const KW_NORMATIVE: number;
    export const KW_DRAFT: number;
    export const KW_FROM: number;
    export const KW_EXAMPLE: number;
    export const KW_PREFERRED: number;
    export const KW_EXTENSIBLE: number;
    export const KW_REQUIRED: number;
    export const KW_CONTAINS: number;
    export const KW_NAMED: number;
    export const KW_AND: number;
    export const KW_ONLY: number;
    export const KW_OR: number;
    export const KW_OBEYS: number;
    export const KW_TRUE: number;
    export const KW_FALSE: number;
    export const KW_INCLUDE: number;
    export const KW_EXCLUDE: number;
    export const KW_CODES: number;
    export const KW_WHERE: number;
    export const KW_VSREFERENCE: number;
    export const KW_SYSTEM: number;
    export const KW_EXACTLY: number;
    export const KW_INSERT: number;
    export const KW_CONTENTREFERENCE: number;
    export const EQUAL: number;
    export const STAR: number;
    export const COLON: number;
    export const COMMA: number;
    export const ARROW: number;
    export const STRING: number;
    export const MULTILINE_STRING: number;
    export const NUMBER: number;
    export const UNIT: number;
    export const CODE: number;
    export const CONCEPT_STRING: number;
    export const DATETIME: number;
    export const TIME: number;
    export const CARD: number;
    export const REFERENCE: number;
    export const CANONICAL: number;
    export const CARET_SEQUENCE: number;
    export const REGEX: number;
    export const PARAMETER_DEF_LIST: number;
    export const BLOCK_COMMENT: number;
    export const SEQUENCE: number;
    export const WHITESPACE: number;
    export const LINE_COMMENT: number;
    export const PARAM_RULESET_REFERENCE: number;
    export const RULESET_REFERENCE: number;
    export const BRACKETED_PARAM: number;
    export const LAST_BRACKETED_PARAM: number;
    export const PLAIN_PARAM: number;
    export const LAST_PLAIN_PARAM: number;
    export const RULE_doc: number;
    export const RULE_entity: number;
    export const RULE_alias: number;
    export const RULE_profile: number;
    export const RULE_extension: number;
    export const RULE_logical: number;
    export const RULE_resource: number;
    export const RULE_sdMetadata: number;
    export const RULE_sdRule: number;
    export const RULE_lrRule: number;
    export const RULE_instance: number;
    export const RULE_instanceMetadata: number;
    export const RULE_instanceRule: number;
    export const RULE_invariant: number;
    export const RULE_invariantMetadata: number;
    export const RULE_invariantRule: number;
    export const RULE_valueSet: number;
    export const RULE_vsMetadata: number;
    export const RULE_vsRule: number;
    export const RULE_codeSystem: number;
    export const RULE_csMetadata: number;
    export const RULE_csRule: number;
    export const RULE_ruleSet: number;
    export const RULE_ruleSetRule: number;
    export const RULE_paramRuleSet: number;
    export const RULE_paramRuleSetRef: number;
    export const RULE_parameter: number;
    export const RULE_lastParameter: number;
    export const RULE_paramRuleSetContent: number;
    export const RULE_mapping: number;
    export const RULE_mappingMetadata: number;
    export const RULE_mappingEntityRule: number;
    export const RULE_parent: number;
    export const RULE_id: number;
    export const RULE_title: number;
    export const RULE_description: number;
    export const RULE_expression: number;
    export const RULE_xpath: number;
    export const RULE_severity: number;
    export const RULE_instanceOf: number;
    export const RULE_usage: number;
    export const RULE_source: number;
    export const RULE_target: number;
    export const RULE_cardRule: number;
    export const RULE_flagRule: number;
    export const RULE_valueSetRule: number;
    export const RULE_fixedValueRule: number;
    export const RULE_containsRule: number;
    export const RULE_onlyRule: number;
    export const RULE_obeysRule: number;
    export const RULE_caretValueRule: number;
    export const RULE_codeCaretValueRule: number;
    export const RULE_mappingRule: number;
    export const RULE_insertRule: number;
    export const RULE_codeInsertRule: number;
    export const RULE_addCRElementRule: number;
    export const RULE_addElementRule: number;
    export const RULE_pathRule: number;
    export const RULE_vsComponent: number;
    export const RULE_vsConceptComponent: number;
    export const RULE_vsFilterComponent: number;
    export const RULE_vsComponentFrom: number;
    export const RULE_vsFromSystem: number;
    export const RULE_vsFromValueset: number;
    export const RULE_vsFilterList: number;
    export const RULE_vsFilterDefinition: number;
    export const RULE_vsFilterOperator: number;
    export const RULE_vsFilterValue: number;
    export const RULE_name: number;
    export const RULE_path: number;
    export const RULE_caretPath: number;
    export const RULE_flag: number;
    export const RULE_strength: number;
    export const RULE_value: number;
    export const RULE_item: number;
    export const RULE_code: number;
    export const RULE_concept: number;
    export const RULE_quantity: number;
    export const RULE_ratio: number;
    export const RULE_reference: number;
    export const RULE_referenceType: number;
    export const RULE_canonical: number;
    export const RULE_ratioPart: number;
    export const RULE_bool: number;
    export const RULE_targetType: number;
    export const RULE_mostAlphaKeywords: number;
    export { DocContext };
    export { EntityContext };
    export { AliasContext };
    export { ProfileContext };
    export { ExtensionContext };
    export { LogicalContext };
    export { ResourceContext };
    export { SdMetadataContext };
    export { SdRuleContext };
    export { LrRuleContext };
    export { InstanceContext };
    export { InstanceMetadataContext };
    export { InstanceRuleContext };
    export { InvariantContext };
    export { InvariantMetadataContext };
    export { InvariantRuleContext };
    export { ValueSetContext };
    export { VsMetadataContext };
    export { VsRuleContext };
    export { CodeSystemContext };
    export { CsMetadataContext };
    export { CsRuleContext };
    export { RuleSetContext };
    export { RuleSetRuleContext };
    export { ParamRuleSetContext };
    export { ParamRuleSetRefContext };
    export { ParameterContext };
    export { LastParameterContext };
    export { ParamRuleSetContentContext };
    export { MappingContext };
    export { MappingMetadataContext };
    export { MappingEntityRuleContext };
    export { ParentContext };
    export { IdContext };
    export { TitleContext };
    export { DescriptionContext };
    export { ExpressionContext };
    export { XpathContext };
    export { SeverityContext };
    export { InstanceOfContext };
    export { UsageContext };
    export { SourceContext };
    export { TargetContext };
    export { CardRuleContext };
    export { FlagRuleContext };
    export { ValueSetRuleContext };
    export { FixedValueRuleContext };
    export { ContainsRuleContext };
    export { OnlyRuleContext };
    export { ObeysRuleContext };
    export { CaretValueRuleContext };
    export { CodeCaretValueRuleContext };
    export { MappingRuleContext };
    export { InsertRuleContext };
    export { CodeInsertRuleContext };
    export { AddCRElementRuleContext };
    export { AddElementRuleContext };
    export { PathRuleContext };
    export { VsComponentContext };
    export { VsConceptComponentContext };
    export { VsFilterComponentContext };
    export { VsComponentFromContext };
    export { VsFromSystemContext };
    export { VsFromValuesetContext };
    export { VsFilterListContext };
    export { VsFilterDefinitionContext };
    export { VsFilterOperatorContext };
    export { VsFilterValueContext };
    export { NameContext };
    export { PathContext };
    export { CaretPathContext };
    export { FlagContext };
    export { StrengthContext };
    export { ValueContext };
    export { ItemContext };
    export { CodeContext };
    export { ConceptContext };
    export { QuantityContext };
    export { RatioContext };
    export { ReferenceContext };
    export { ReferenceTypeContext };
    export { CanonicalContext };
    export { RatioPartContext };
    export { BoolContext };
    export { TargetTypeContext };
    export { MostAlphaKeywordsContext };
}
export default FSHParser;
import antlr4 from "antlr4";
declare class DocContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EOF(): antlr4.Token;
    entity: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EntityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    alias(): any;
    profile(): any;
    extension(): any;
    invariant(): any;
    instance(): any;
    valueSet(): any;
    codeSystem(): any;
    ruleSet(): any;
    paramRuleSet(): any;
    mapping(): any;
    logical(): any;
    resource(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AliasContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_ALIAS(): antlr4.Token;
    SEQUENCE: (i: any) => any;
    EQUAL(): antlr4.Token;
    CODE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ProfileContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_PROFILE(): antlr4.Token;
    name(): any;
    sdMetadata: (i: any) => any;
    sdRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExtensionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXTENSION(): antlr4.Token;
    name(): any;
    sdMetadata: (i: any) => any;
    sdRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LogicalContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_LOGICAL(): antlr4.Token;
    name(): any;
    sdMetadata: (i: any) => any;
    lrRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResourceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RESOURCE(): antlr4.Token;
    name(): any;
    sdMetadata: (i: any) => any;
    lrRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SdMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    parent(): any;
    id(): any;
    title(): any;
    description(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SdRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cardRule(): any;
    flagRule(): any;
    valueSetRule(): any;
    fixedValueRule(): any;
    containsRule(): any;
    onlyRule(): any;
    obeysRule(): any;
    caretValueRule(): any;
    insertRule(): any;
    pathRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LrRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    sdRule(): any;
    addElementRule(): any;
    addCRElementRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INSTANCE(): antlr4.Token;
    name(): any;
    instanceMetadata: (i: any) => any;
    instanceRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    instanceOf(): any;
    title(): any;
    description(): any;
    usage(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fixedValueRule(): any;
    insertRule(): any;
    pathRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INVARIANT(): antlr4.Token;
    name(): any;
    invariantMetadata: (i: any) => any;
    invariantRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    description(): any;
    expression(): any;
    xpath(): any;
    severity(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvariantRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fixedValueRule(): any;
    insertRule(): any;
    pathRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_VALUESET(): antlr4.Token;
    name(): any;
    vsMetadata: (i: any) => any;
    vsRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): any;
    title(): any;
    description(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    vsComponent(): any;
    caretValueRule(): any;
    insertRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeSystemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CODESYSTEM(): antlr4.Token;
    name(): any;
    csMetadata: (i: any) => any;
    csRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CsMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): any;
    title(): any;
    description(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    concept(): any;
    codeCaretValueRule(): any;
    codeInsertRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RuleSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RULESET(): antlr4.Token;
    RULESET_REFERENCE(): antlr4.Token;
    ruleSetRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RuleSetRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    sdRule(): any;
    addElementRule(): any;
    addCRElementRule(): any;
    concept(): any;
    codeCaretValueRule(): any;
    codeInsertRule(): any;
    vsComponent(): any;
    mappingRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_RULESET(): antlr4.Token;
    paramRuleSetRef(): any;
    paramRuleSetContent(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetRefContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PARAM_RULESET_REFERENCE(): antlr4.Token;
    lastParameter(): any;
    parameter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BRACKETED_PARAM(): antlr4.Token;
    PLAIN_PARAM(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LastParameterContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LAST_BRACKETED_PARAM(): antlr4.Token;
    LAST_PLAIN_PARAM(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParamRuleSetContentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    KW_PROFILE: (i: any) => any;
    KW_ALIAS: (i: any) => any;
    KW_EXTENSION: (i: any) => any;
    KW_INSTANCE: (i: any) => any;
    KW_INVARIANT: (i: any) => any;
    KW_VALUESET: (i: any) => any;
    KW_CODESYSTEM: (i: any) => any;
    KW_RULESET: (i: any) => any;
    KW_MAPPING: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MAPPING(): antlr4.Token;
    name(): any;
    mappingMetadata: (i: any) => any;
    mappingEntityRule: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingMetadataContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    id(): any;
    source(): any;
    target(): any;
    description(): any;
    title(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingEntityRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    mappingRule(): any;
    insertRule(): any;
    pathRule(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_PARENT(): antlr4.Token;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_ID(): antlr4.Token;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TitleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TITLE(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DescriptionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_DESCRIPTION(): antlr4.Token;
    STRING(): antlr4.Token;
    MULTILINE_STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXPRESSION(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XpathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_XPATH(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SeverityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SEVERITY(): antlr4.Token;
    CODE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceOfContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_INSTANCEOF(): antlr4.Token;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UsageContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_USAGE(): antlr4.Token;
    CODE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SourceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SOURCE(): antlr4.Token;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TargetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TARGET(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CardRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    CARD(): antlr4.Token;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FlagRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path: (i: any) => any;
    KW_AND: (i: any) => any;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueSetRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    KW_FROM(): antlr4.Token;
    name(): any;
    strength(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FixedValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    EQUAL(): antlr4.Token;
    value(): any;
    KW_EXACTLY(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContainsRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    KW_CONTAINS(): antlr4.Token;
    item: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnlyRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    KW_ONLY(): antlr4.Token;
    targetType: (i: any) => any;
    KW_OR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObeysRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    KW_OBEYS(): antlr4.Token;
    name: (i: any) => any;
    path(): any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaretValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    caretPath(): any;
    EQUAL(): antlr4.Token;
    value(): any;
    path(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeCaretValueRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    caretPath(): any;
    EQUAL(): antlr4.Token;
    value(): any;
    CODE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MappingRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    ARROW(): antlr4.Token;
    STRING: (i: any) => any;
    path(): any;
    CODE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InsertRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    KW_INSERT(): antlr4.Token;
    RULESET_REFERENCE(): antlr4.Token;
    paramRuleSetRef(): any;
    path(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeInsertRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    KW_INSERT(): antlr4.Token;
    RULESET_REFERENCE(): antlr4.Token;
    paramRuleSetRef(): any;
    CODE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddCRElementRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    CARD(): antlr4.Token;
    KW_CONTENTREFERENCE(): antlr4.Token;
    STRING: (i: any) => any;
    SEQUENCE(): antlr4.Token;
    CODE(): antlr4.Token;
    flag: (i: any) => any;
    MULTILINE_STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddElementRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    CARD(): antlr4.Token;
    targetType: (i: any) => any;
    STRING: (i: any) => any;
    flag: (i: any) => any;
    KW_OR: (i: any) => any;
    MULTILINE_STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PathRuleContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    path(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    vsConceptComponent(): any;
    vsFilterComponent(): any;
    KW_INCLUDE(): antlr4.Token;
    KW_EXCLUDE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsConceptComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    code: (i: any) => any;
    vsComponentFrom(): any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterComponentContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_CODES(): antlr4.Token;
    vsComponentFrom(): any;
    KW_WHERE(): antlr4.Token;
    vsFilterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsComponentFromContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_FROM(): antlr4.Token;
    vsFromSystem(): any;
    vsFromValueset(): any;
    KW_AND(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFromSystemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_SYSTEM(): antlr4.Token;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFromValuesetContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_VSREFERENCE(): antlr4.Token;
    name: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterListContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    vsFilterDefinition: (i: any) => any;
    KW_AND: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterDefinitionContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name(): any;
    vsFilterOperator(): any;
    vsFilterValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterOperatorContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EQUAL(): antlr4.Token;
    SEQUENCE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsFilterValueContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    code(): any;
    KW_TRUE(): antlr4.Token;
    KW_FALSE(): antlr4.Token;
    REGEX(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NameContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SEQUENCE(): antlr4.Token;
    NUMBER(): antlr4.Token;
    KW_MS(): antlr4.Token;
    KW_SU(): antlr4.Token;
    KW_TU(): antlr4.Token;
    KW_NORMATIVE(): antlr4.Token;
    KW_DRAFT(): antlr4.Token;
    KW_CODES(): antlr4.Token;
    KW_VSREFERENCE(): antlr4.Token;
    KW_SYSTEM(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SEQUENCE(): antlr4.Token;
    NUMBER(): antlr4.Token;
    mostAlphaKeywords(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaretPathContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CARET_SEQUENCE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FlagContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MOD(): antlr4.Token;
    KW_MS(): antlr4.Token;
    KW_SU(): antlr4.Token;
    KW_TU(): antlr4.Token;
    KW_NORMATIVE(): antlr4.Token;
    KW_DRAFT(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StrengthContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_EXAMPLE(): antlr4.Token;
    KW_PREFERRED(): antlr4.Token;
    KW_EXTENSIBLE(): antlr4.Token;
    KW_REQUIRED(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STRING(): antlr4.Token;
    MULTILINE_STRING(): antlr4.Token;
    NUMBER(): antlr4.Token;
    DATETIME(): antlr4.Token;
    TIME(): antlr4.Token;
    reference(): any;
    canonical(): any;
    code(): any;
    quantity(): any;
    ratio(): any;
    bool(): any;
    name(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ItemContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name: (i: any) => any;
    CARD(): antlr4.Token;
    KW_NAMED(): antlr4.Token;
    flag: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CodeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CODE(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConceptContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STAR(): antlr4.Token;
    CODE: (i: any) => any;
    STRING: (i: any) => any;
    MULTILINE_STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QuantityContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NUMBER(): antlr4.Token;
    UNIT(): antlr4.Token;
    CODE(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RatioContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ratioPart: (i: any) => any;
    COLON(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReferenceContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REFERENCE(): antlr4.Token;
    STRING(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReferenceTypeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REFERENCE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CanonicalContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CANONICAL(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RatioPartContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NUMBER(): antlr4.Token;
    quantity(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BoolContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_TRUE(): antlr4.Token;
    KW_FALSE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TargetTypeContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    name(): any;
    referenceType(): any;
    canonical(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MostAlphaKeywordsContext extends antlr4.ParserRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KW_MS(): antlr4.Token;
    KW_SU(): antlr4.Token;
    KW_TU(): antlr4.Token;
    KW_NORMATIVE(): antlr4.Token;
    KW_DRAFT(): antlr4.Token;
    KW_FROM(): antlr4.Token;
    KW_CONTAINS(): antlr4.Token;
    KW_NAMED(): antlr4.Token;
    KW_AND(): antlr4.Token;
    KW_ONLY(): antlr4.Token;
    KW_OR(): antlr4.Token;
    KW_OBEYS(): antlr4.Token;
    KW_TRUE(): antlr4.Token;
    KW_FALSE(): antlr4.Token;
    KW_INCLUDE(): antlr4.Token;
    KW_EXCLUDE(): antlr4.Token;
    KW_CODES(): antlr4.Token;
    KW_WHERE(): antlr4.Token;
    KW_VSREFERENCE(): antlr4.Token;
    KW_SYSTEM(): antlr4.Token;
    KW_CONTENTREFERENCE(): antlr4.Token;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
