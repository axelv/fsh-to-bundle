"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FSHTank = void 0;
const fshtypes_1 = require("../fshtypes");
const rules_1 = require("../fshtypes/rules");
const Fishable_1 = require("../utils/Fishable");
const common_1 = require("../fhirtypes/common");
const flatMap_1 = __importDefault(require("lodash/flatMap"));
class FSHTank {
    constructor(docs, config) {
        this.docs = docs;
        this.config = config;
    }
    /**
     * Gets all profiles in the tank
     * @returns {Profile[]}
     */
    getAllProfiles() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.profiles.values()));
    }
    /**
     * Gets all extensions in the tank
     * @returns {Extension[]}
     */
    getAllExtensions() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.extensions.values()));
    }
    /**
     * Gets all logical models in the tank
     * @returns {Logical[]}
     */
    getAllLogicals() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.logicals.values()));
    }
    /**
     * Gets all resources in the tank
     * @returns {Resource[]}
     */
    getAllResources() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.resources.values()));
    }
    /**
     * Gets all instances in the tank
     * @returns {Instance[]}
     */
    getAllInstances() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.instances.values()));
    }
    /**
     * Gets all structure definitions (i.e., FshStructures) (profiles, extensions,
     * logical models, and resources) in the tank.
     * @returns {(Profile | Extension)[]}
     */
    getAllStructureDefinitions() {
        return [
            ...this.getAllProfiles(),
            ...this.getAllExtensions(),
            ...this.getAllLogicals(),
            ...this.getAllResources()
        ];
    }
    /**
     * Gets all value sets in the tank
     * @returns {FshValueSet[]}
     */
    getAllValueSets() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.valueSets.values()));
    }
    /**
     * Gets all code systems in the tank
     * @returns {FshCodeSystem[]}
     */
    getAllCodeSystems() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.codeSystems.values()));
    }
    /**
     * Gets all invariants in the tank
     * @returns {Invariant[]}
     */
    getAllInvariants() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.invariants.values()));
    }
    /**
     * Gets all ruleSets in the tank
     * @returns {RuleSet[]}
     */
    getAllRuleSets() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.ruleSets.values()));
    }
    /**
     * Gets all Mappings in the tank
     * @returns {Mapping[]}
     */
    getAllMappings() {
        return (0, flatMap_1.default)(this.docs, doc => Array.from(doc.mappings.values()));
    }
    /**
     * Finds the alias in the tank, if it exists
     * @param {string} name - The name of the alias we're looking for
     * @returns {string | undefined}
     */
    resolveAlias(name) {
        for (const doc of this.docs) {
            const foundAlias = doc.aliases.get(name);
            if (foundAlias)
                return foundAlias;
        }
        return undefined;
    }
    fish(item, ...types) {
        var _a, _b;
        // Resolve alias if necessary
        item = (_a = this.resolveAlias(item)) !== null && _a !== void 0 ? _a : item;
        // version needs to be checked separately from the base
        const [base, ...versionParts] = (_b = item === null || item === void 0 ? void 0 : item.split('|')) !== null && _b !== void 0 ? _b : ['', ''];
        const version = versionParts.join('|') || null;
        // No types passed in means to search ALL supported types
        if (types.length === 0) {
            types = [
                Fishable_1.Type.Profile,
                Fishable_1.Type.Extension,
                Fishable_1.Type.Logical,
                Fishable_1.Type.Resource,
                Fishable_1.Type.ValueSet,
                Fishable_1.Type.CodeSystem,
                Fishable_1.Type.Instance,
                Fishable_1.Type.Invariant,
                Fishable_1.Type.RuleSet,
                Fishable_1.Type.Mapping
            ];
        }
        for (const t of types) {
            let result;
            switch (t) {
                case Fishable_1.Type.Profile:
                    result = this.getAllProfiles().find(p => (p.name === base ||
                        p.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(p, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(p, this.config.version)));
                    if (!result) {
                        result = this.getAllInstances().find(profileInstance => profileInstance.instanceOf === 'StructureDefinition' &&
                            profileInstance.usage === 'Definition' &&
                            (profileInstance.name === base ||
                                profileInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(profileInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version === (0, common_1.getVersionFromFshDefinition)(profileInstance, this.config.version)) &&
                            profileInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'derivation' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'constraint') &&
                            !profileInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'type' &&
                                rule.value === 'Extension'));
                    }
                    break;
                case Fishable_1.Type.Extension:
                    result = this.getAllExtensions().find(e => (e.name === base ||
                        e.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(e, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(e, this.config.version)));
                    if (!result) {
                        // There may be a matching definitional Instance of StructureDefinition with type Extension
                        result = this.getAllInstances().find(extensionInstance => extensionInstance.instanceOf === 'StructureDefinition' &&
                            extensionInstance.usage === 'Definition' &&
                            (extensionInstance.name === base ||
                                extensionInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(extensionInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version ===
                                    (0, common_1.getVersionFromFshDefinition)(extensionInstance, this.config.version)) &&
                            extensionInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'derivation' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'constraint') &&
                            extensionInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'type' &&
                                rule.value === 'Extension'));
                    }
                    break;
                case Fishable_1.Type.Logical:
                    result = this.getAllLogicals().find(l => (l.name === base ||
                        l.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(l, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(l, this.config.version)));
                    if (!result) {
                        result = this.getAllInstances().find(logicalInstance => logicalInstance.instanceOf === 'StructureDefinition' &&
                            logicalInstance.usage === 'Definition' &&
                            (logicalInstance.name === base ||
                                logicalInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(logicalInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version === (0, common_1.getVersionFromFshDefinition)(logicalInstance, this.config.version)) &&
                            logicalInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'derivation' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'specialization') &&
                            logicalInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'kind' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'logical'));
                    }
                    break;
                case Fishable_1.Type.Resource:
                    result = this.getAllResources().find(r => (r.name === base ||
                        r.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(r, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(r, this.config.version)));
                    if (!result) {
                        result = this.getAllInstances().find(resourceInstance => resourceInstance.instanceOf === 'StructureDefinition' &&
                            resourceInstance.usage === 'Definition' &&
                            (resourceInstance.name === base ||
                                resourceInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(resourceInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version === (0, common_1.getVersionFromFshDefinition)(resourceInstance, this.config.version)) &&
                            resourceInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'derivation' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'specialization') &&
                            resourceInstance.rules.some(rule => rule instanceof rules_1.AssignmentRule &&
                                rule.path === 'kind' &&
                                rule.value instanceof fshtypes_1.FshCode &&
                                rule.value.code === 'resource'));
                    }
                    break;
                case Fishable_1.Type.ValueSet:
                    result = this.getAllValueSets().find(vs => (vs.name === base ||
                        vs.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(vs, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(vs, this.config.version)));
                    if (!result) {
                        result = this.getAllInstances().find(vsInstance => (vsInstance === null || vsInstance === void 0 ? void 0 : vsInstance.instanceOf) === 'ValueSet' &&
                            (vsInstance === null || vsInstance === void 0 ? void 0 : vsInstance.usage) === 'Definition' &&
                            ((vsInstance === null || vsInstance === void 0 ? void 0 : vsInstance.name) === base ||
                                vsInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(vsInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version === (0, common_1.getVersionFromFshDefinition)(vsInstance, this.config.version)));
                    }
                    break;
                case Fishable_1.Type.CodeSystem:
                    result = this.getAllCodeSystems().find(cs => (cs.name === base ||
                        cs.id === base ||
                        (0, common_1.getUrlFromFshDefinition)(cs, this.config.canonical) === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(cs, this.config.version)));
                    if (!result) {
                        result = this.getAllInstances().find(csInstance => (csInstance === null || csInstance === void 0 ? void 0 : csInstance.instanceOf) === 'CodeSystem' &&
                            (csInstance === null || csInstance === void 0 ? void 0 : csInstance.usage) === 'Definition' &&
                            ((csInstance === null || csInstance === void 0 ? void 0 : csInstance.name) === base ||
                                csInstance.id === base ||
                                (0, common_1.getUrlFromFshDefinition)(csInstance, this.config.canonical) === base) &&
                            (version == null ||
                                version === (0, common_1.getVersionFromFshDefinition)(csInstance, this.config.version)));
                    }
                    break;
                case Fishable_1.Type.Instance:
                    result = this.getAllInstances().find(i => (i.name === base || i.id === base) &&
                        (version == null || version === (0, common_1.getVersionFromFshDefinition)(i, this.config.version)));
                    break;
                case Fishable_1.Type.Invariant:
                    result = this.getAllInvariants().find(i => i.name === base);
                    break;
                case Fishable_1.Type.RuleSet:
                    result = this.getAllRuleSets().find(r => r.name === base);
                    break;
                case Fishable_1.Type.Mapping:
                    result = this.getAllMappings().find(m => m.name === base);
                    break;
                case Fishable_1.Type.Type:
                default:
                    // Tank doesn't support these types
                    break;
            }
            if (result != null) {
                return result;
            }
        }
        // No match, return undefined
        return;
    }
    fishForAppliedRuleSet(item) {
        for (const doc of this.docs) {
            const ruleSet = doc.appliedRuleSets.get(item);
            if (ruleSet) {
                return ruleSet;
            }
        }
    }
    fishForMetadata(item, ...types) {
        var _a;
        const result = this.fish(item, ...types);
        if (result) {
            const meta = {
                id: result.id,
                name: result.name
            };
            if (result instanceof fshtypes_1.Profile ||
                result instanceof fshtypes_1.Extension ||
                result instanceof fshtypes_1.Logical ||
                result instanceof fshtypes_1.Resource) {
                meta.url = (0, common_1.getUrlFromFshDefinition)(result, this.config.canonical);
                meta.parent = result.parent;
                meta.resourceType = 'StructureDefinition';
                if (result instanceof fshtypes_1.Logical) {
                    // Logical models should always use an absolute URL as their StructureDefinition.type
                    // unless HL7 published them. In that case, the URL is relative to
                    // http://hl7.org/fhir/StructureDefinition/.
                    // Ref: https://chat.fhir.org/#narrow/stream/179177-conformance/topic/StructureDefinition.2Etype.20for.20Logical.20Models.2FCustom.20Resources/near/240488388
                    const HL7_URL = 'http://hl7.org/fhir/StructureDefinition/';
                    meta.sdType = meta.url.startsWith(HL7_URL) ? meta.url.slice(HL7_URL.length) : meta.url;
                }
            }
            else if (result instanceof fshtypes_1.FshValueSet || result instanceof fshtypes_1.FshCodeSystem) {
                meta.url = (0, common_1.getUrlFromFshDefinition)(result, this.config.canonical);
                if (result instanceof fshtypes_1.FshValueSet) {
                    meta.resourceType = 'ValueSet';
                }
                else {
                    meta.resourceType = 'CodeSystem';
                }
            }
            else if (result instanceof fshtypes_1.Instance) {
                (_a = result.rules) === null || _a === void 0 ? void 0 : _a.forEach(r => {
                    if (r.path === 'url' && r instanceof rules_1.AssignmentRule && typeof r.value === 'string') {
                        meta.url = r.value;
                        // don't break; keep looping in case there is a later rule that re-assigns url
                    }
                });
                meta.instanceUsage = result.usage;
            }
            return meta;
        }
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fishForFHIR(item, ...types) {
        // the FSHTank cannot return FHIR definitions, but we define this function
        // in order to implement the Fishable interface
    }
}
exports.FSHTank = FSHTank;
//# sourceMappingURL=FSHTank.js.map