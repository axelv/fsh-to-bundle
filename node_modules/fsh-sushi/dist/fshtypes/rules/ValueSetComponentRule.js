"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetFilterComponentRule = exports.ValueSetConceptComponentRule = exports.ValueSetComponentRule = void 0;
const Rule_1 = require("./Rule");
const os_1 = require("os");
class ValueSetComponentRule extends Rule_1.Rule {
    constructor(inclusion) {
        super('');
        this.inclusion = inclusion;
        this.from = {};
    }
    get constructorName() {
        return 'ValueSetComponentRule';
    }
    toFSH() {
        return `* ${this.inclusion ? 'include' : 'exclude'} codes${fromString(this.from)}`;
    }
}
exports.ValueSetComponentRule = ValueSetComponentRule;
class ValueSetConceptComponentRule extends ValueSetComponentRule {
    constructor() {
        super(...arguments);
        this.concepts = [];
    }
    get constructorName() {
        return 'ValueSetConceptComponentRule';
    }
    toFSH() {
        var _a;
        // if this rule has valueSets in its "from" definition, write using the typical syntax
        // otherwise, write each code on its own line, and omit "include" and "from system"
        if (((_a = this.from.valueSets) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const inclusionPart = `* ${this.inclusion ? 'include' : 'exclude'} `;
            let conceptPart = this.concepts.map(concept => concept.toString()).join(' and ');
            let fromPart = fromString(this.from);
            // if the result is more than 100 characters long, build it again, but with linebreaks
            if (inclusionPart.length + conceptPart.length + fromPart.length > 100) {
                conceptPart = this.concepts.map(concept => concept.toString()).join(` and${os_1.EOL}    `);
                fromPart = `${os_1.EOL}   ` + fromString(this.from, ` and${os_1.EOL}    `);
            }
            return `${inclusionPart}${conceptPart}${fromPart}`;
        }
        else {
            const inclusionPart = `* ${this.inclusion ? '' : 'exclude '}`;
            return this.concepts
                .map(concept => {
                if (!concept.system && this.from.system) {
                    concept.system = this.from.system;
                }
                return `${inclusionPart}${concept}`;
            })
                .join(os_1.EOL);
        }
    }
}
exports.ValueSetConceptComponentRule = ValueSetConceptComponentRule;
class ValueSetFilterComponentRule extends ValueSetComponentRule {
    constructor() {
        super(...arguments);
        this.filters = [];
    }
    get constructorName() {
        return 'ValueSetFilterComponentRule';
    }
    toFSH() {
        const inclusionPart = `* ${this.inclusion ? 'include' : 'exclude'} codes`;
        let fromPart = fromString(this.from);
        let filterPart = this.buildFilterString();
        // if the result is more than 100 characters long, build it again, but with linebreaks
        if (inclusionPart.length + fromPart.length + filterPart.length > 100) {
            fromPart = fromString(this.from, ` and${os_1.EOL}    `);
            filterPart = `${os_1.EOL}   ` + this.buildFilterString(` and${os_1.EOL}    `);
        }
        return `${inclusionPart}${fromPart}${filterPart}`;
    }
    buildFilterString(separator = ' and ') {
        if (this.filters.length) {
            return (' where ' +
                this.filters
                    .map(filter => `${filter.property} ${filter.operator} ${typeof filter.value === 'string'
                    ? `"${filter.value.toString()}"`
                    : filter.value.toString()}`)
                    .join(separator));
        }
        else {
            return '';
        }
    }
}
exports.ValueSetFilterComponentRule = ValueSetFilterComponentRule;
function fromString(from, separator = ' and ') {
    if (from.system == null && from.valueSets == null)
        return '';
    let fromString = ' from ';
    if (from.system) {
        fromString += `system ${from.system}`;
    }
    if (from.valueSets) {
        fromString += `${from.system ? separator : ''}valueset ${from.valueSets.join(separator)}`;
    }
    return fromString;
}
//# sourceMappingURL=ValueSetComponentRule.js.map