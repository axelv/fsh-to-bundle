"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findIdAssignmentRule = exports.findIdCaretRule = exports.fshifyString = exports.typeString = void 0;
const rules_1 = require("./rules");
const lodash_1 = require("lodash");
function typeString(types) {
    const references = [];
    const canonicals = [];
    const normals = [];
    types.forEach(t => {
        if (t.isReference) {
            references.push(t);
        }
        else if (t.isCanonical) {
            canonicals.push(t);
        }
        else {
            normals.push(t);
        }
    });
    const normalString = normals.map(t => t.type).join(' or ');
    const referenceString = references.length
        ? `Reference(${references.map(t => t.type).join(' or ')})`
        : '';
    const canonicalString = canonicals.length
        ? `Canonical(${canonicals.map(t => t.type).join(' or ')})`
        : '';
    return [normalString, referenceString, canonicalString].filter(s => s).join(' or ');
}
exports.typeString = typeString;
// Adds expected backslash-escapes to a string to make it a FSH string
function fshifyString(input) {
    return input
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\t/g, '\\t');
}
exports.fshifyString = fshifyString;
function findIdCaretRule(rules) {
    return (0, lodash_1.findLast)(rules, rule => rule instanceof rules_1.CaretValueRule &&
        rule.path === '' &&
        rule.caretPath === 'id' &&
        typeof rule.value === 'string');
}
exports.findIdCaretRule = findIdCaretRule;
function findIdAssignmentRule(rules) {
    return (0, lodash_1.findLast)(rules, rule => rule instanceof rules_1.AssignmentRule && rule.path === 'id' && typeof rule.value === 'string');
}
exports.findIdAssignmentRule = findIdAssignmentRule;
//# sourceMappingURL=common.js.map