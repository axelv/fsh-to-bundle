"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueSetExporter = void 0;
const fhirtypes_1 = require("../fhirtypes");
const fshtypes_1 = require("../fshtypes");
const FSHLogger_1 = require("../utils/FSHLogger");
const errors_1 = require("../errors");
const _1 = require(".");
const utils_1 = require("../utils");
const rules_1 = require("../fshtypes/rules");
const common_1 = require("../fhirtypes/common");
const valid_url_1 = require("valid-url");
const lodash_1 = require("lodash");
class ValueSetExporter {
    constructor(tank, pkg, fisher) {
        this.tank = tank;
        this.pkg = pkg;
        this.fisher = fisher;
    }
    setMetadata(valueSet, fshDefinition) {
        valueSet.setName(fshDefinition);
        valueSet.setId(fshDefinition);
        if (fshDefinition.title == '') {
            FSHLogger_1.logger.warn(`Value set ${fshDefinition.name} has a title field that should not be empty.`);
        }
        if (fshDefinition.description == '') {
            FSHLogger_1.logger.warn(`Value set ${fshDefinition.name} has a description field that should not be empty.`);
        }
        if (fshDefinition.title) {
            valueSet.title = fshDefinition.title;
        }
        if (fshDefinition.description) {
            valueSet.description = fshDefinition.description;
        }
        delete valueSet.version; // deleting to allow the IG Publisher default to take hold
        valueSet.status = this.tank.config.status;
        valueSet.url = `${this.tank.config.canonical}/ValueSet/${valueSet.id}`;
    }
    setCompose(valueSet, components) {
        if (components.length > 0) {
            valueSet.compose = {
                include: [],
                exclude: []
            };
            components.forEach(component => {
                var _a, _b;
                const composeElement = {};
                if (component.from.system) {
                    const systemParts = component.from.system.split('|');
                    const csMetadata = this.fisher.fishForMetadata(component.from.system, utils_1.Type.CodeSystem);
                    const foundSystem = component.from.system
                        .replace(/^([^|]+)/, (_a = csMetadata === null || csMetadata === void 0 ? void 0 : csMetadata.url) !== null && _a !== void 0 ? _a : '$1')
                        .split('|');
                    composeElement.system = foundSystem[0];
                    // if the rule specified a version, use that version.
                    composeElement.version = systemParts.slice(1).join('|') || undefined;
                    if (!(0, valid_url_1.isUri)(composeElement.system)) {
                        throw new errors_1.InvalidUriError(composeElement.system);
                    }
                }
                if (component.from.valueSets) {
                    composeElement.valueSet = component.from.valueSets.map(vs => {
                        var _a, _b;
                        return (_b = (_a = this.fisher.fishForMetadata(vs, utils_1.Type.ValueSet)) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : vs;
                    });
                    composeElement.valueSet.forEach(vs => {
                        // Canonical URI may include | to specify version: https://www.hl7.org/fhir/references.html#canonical
                        if (!(0, valid_url_1.isUri)(vs.split('|')[0])) {
                            throw new errors_1.InvalidUriError(vs);
                        }
                    });
                }
                if (component instanceof rules_1.ValueSetConceptComponentRule && component.concepts.length > 0) {
                    composeElement.concept = component.concepts.map(concept => {
                        const composeConcept = {
                            code: concept.code
                        };
                        if (concept.display) {
                            composeConcept.display = concept.display;
                        }
                        return composeConcept;
                    });
                    // if we can fish up the system in the tank, it's local, and we should check the listed concepts
                    const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                    if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                        (0, common_1.listUndefinedLocalCodes)(codeSystem, composeElement.concept.map(concept => concept.code), this.tank, component);
                    }
                }
                else if (component instanceof rules_1.ValueSetFilterComponentRule &&
                    component.filters.length > 0) {
                    composeElement.filter = component.filters.map(filter => {
                        // if filter.value is a FshCode, perform the local code system check here as well
                        if (filter.value instanceof fshtypes_1.FshCode) {
                            const codeSystem = this.tank.fish(composeElement.system, utils_1.Type.CodeSystem);
                            if (codeSystem instanceof fshtypes_1.FshCodeSystem || codeSystem instanceof fshtypes_1.Instance) {
                                (0, common_1.listUndefinedLocalCodes)(codeSystem, [filter.value.code], this.tank, component);
                            }
                        }
                        return {
                            property: filter.property.toString(),
                            op: filter.operator.toString(),
                            value: this.filterValueToString(filter.value)
                        };
                    });
                }
                if (component.inclusion) {
                    if (((_b = composeElement.concept) === null || _b === void 0 ? void 0 : _b.length) > 0) {
                        // warn the user if they have already included a concept in this component
                        // concept, system, and version must all match to be considered equal
                        const matchingComposeElements = valueSet.compose.include.filter(compose => {
                            var _a;
                            return (compose.system === composeElement.system &&
                                compose.version === composeElement.version &&
                                ((_a = compose.concept) === null || _a === void 0 ? void 0 : _a.length) > 0);
                        });
                        const potentialMatches = (0, lodash_1.flatMap)(matchingComposeElements, compose => compose.concept).map(concept => concept.code);
                        composeElement.concept = composeElement.concept.filter((concept, idx, currentConcepts) => {
                            if (potentialMatches.includes(concept.code) ||
                                currentConcepts
                                    .slice(0, idx)
                                    .some(duplicateConcept => duplicateConcept.code === concept.code)) {
                                FSHLogger_1.logger.warn(`ValueSet ${valueSet.name} already includes ${composeElement.system}${composeElement.version ? `|${composeElement.version}` : ''}#${concept.code}`, component.sourceInfo);
                                return false;
                            }
                            return true;
                        });
                        if (composeElement.concept.length > 0) {
                            valueSet.compose.include.push(composeElement);
                        }
                    }
                    else {
                        valueSet.compose.include.push(composeElement);
                    }
                }
                else {
                    valueSet.compose.exclude.push(composeElement);
                }
            });
            if (valueSet.compose.exclude.length == 0) {
                delete valueSet.compose.exclude;
            }
        }
    }
    setCaretRules(valueSet, rules) {
        (0, utils_1.resolveSoftIndexing)(rules);
        for (const rule of rules) {
            try {
                if (rule instanceof rules_1.CaretValueRule) {
                    if (rule.isInstance) {
                        const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                        const instance = instanceExporter.fishForFHIR(rule.value);
                        if (instance == null) {
                            FSHLogger_1.logger.error(`Cannot find definition for Instance: ${rule.value}. Skipping rule.`, rule.sourceInfo);
                            continue;
                        }
                        rule.value = instance;
                    }
                    (0, common_1.setPropertyOnDefinitionInstance)(valueSet, rule.caretPath, rule.value, this.fisher);
                }
            }
            catch (originalErr) {
                // if an Instance has an id that looks like a number, bigint, or boolean,
                // we may have tried to assign that value instead of an Instance.
                // try to fish up an Instance with the rule's raw value.
                // if we find one, try assigning that instead.
                if (originalErr instanceof errors_1.MismatchedTypeError &&
                    ['number', 'bigint', 'boolean'].includes(typeof rule.value)) {
                    const instanceExporter = new _1.InstanceExporter(this.tank, this.pkg, this.fisher);
                    (0, common_1.assignInstanceFromRawValue)(valueSet, rule, instanceExporter, this.fisher, originalErr);
                }
                else {
                    FSHLogger_1.logger.error(originalErr.message, rule.sourceInfo);
                }
            }
        }
    }
    filterValueToString(value) {
        if (value instanceof RegExp) {
            return value.source;
        }
        else if (value instanceof fshtypes_1.FshCode) {
            return value.code;
        }
        else {
            return value.toString();
        }
    }
    applyInsertRules() {
        const valueSets = this.tank.getAllValueSets();
        for (const vs of valueSets) {
            (0, common_1.applyInsertRules)(vs, this.tank);
        }
    }
    export() {
        const valueSets = this.tank.getAllValueSets();
        for (const valueSet of valueSets) {
            try {
                this.exportValueSet(valueSet);
            }
            catch (e) {
                FSHLogger_1.logger.error(e.message, valueSet.sourceInfo);
            }
        }
        if (valueSets.length > 0) {
            FSHLogger_1.logger.info(`Converted ${valueSets.length} FHIR ValueSets.`);
        }
        return this.pkg;
    }
    exportValueSet(fshDefinition) {
        if (this.pkg.valueSets.some(vs => vs.name === fshDefinition.name)) {
            return;
        }
        const vs = new fhirtypes_1.ValueSet();
        this.setMetadata(vs, fshDefinition);
        this.setCaretRules(vs, fshDefinition.rules.filter(rule => rule instanceof rules_1.CaretValueRule));
        this.setCompose(vs, fshDefinition.rules.filter(rule => rule instanceof rules_1.ValueSetComponentRule));
        if (vs.compose && vs.compose.include.length == 0) {
            throw new errors_1.ValueSetComposeError(fshDefinition.name);
        }
        // check for another value set with the same id
        // see https://www.hl7.org/fhir/resource.html#id
        if (this.pkg.valueSets.some(valueSet => vs.id === valueSet.id)) {
            FSHLogger_1.logger.error(`Multiple value sets with id ${vs.id}. Each value set must have a unique id.`, fshDefinition.sourceInfo);
        }
        (0, common_1.cleanResource)(vs, (prop) => ['_sliceName', '_primitive'].includes(prop));
        this.pkg.valueSets.push(vs);
        return vs;
    }
}
exports.ValueSetExporter = ValueSetExporter;
//# sourceMappingURL=ValueSetExporter.js.map